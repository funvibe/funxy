package web

import "lib/time" (clockMs)

// --- Middleware ---

fun logger(next) {
    fun(ctx) {
        start = clockMs()
        result = next(ctx)
        duration = clockMs() - start
        req = ctx.req
        match result {
            Ok(res) -> {
                // We rely on duck typing for status access, or autoResponse if needed.
                // But generally handler results should be compatible with Response structure.
                // If we want to be safe against non-Response objects (like VNode returned directly),
                // we should use autoResponse, but autoResponse requires tagged Response to pass through correctly.
                // Since we are fixing handlers to return tagged Responses (or autoResponse will handle them in handleRequest),
                // we can just peek at status if it exists.
                // However, `res` could be "Hello" (String). String doesn't have .status.
                // So we MUST use autoResponse to normalize it for logging.
                respObj = autoResponse(res)
                msg = sprintf("%s %s -> %d (%d ms)", req.method, req.path, respObj.status, duration)
                print(msg)
            }
            Fail(err) -> {
                msg = sprintf("%s %s -> ERROR (%d ms)", req.method, req.path, duration)
                print(msg)
            }
        }
        result
    }
}

fun recover(next) {
    fun(ctx) {
        match next(ctx) {
            Ok(res) -> Ok(res)
            Fail(err) -> {
                resp: Response = { status: 500, headers: [("Content-Type", "text/plain")], body: BodyString("Internal Server Error") }
                Ok(resp)
            }
        }
    }
}

fun cors(next) {
    fun(ctx) {
        if ctx.req.method == "OPTIONS" {
             resp: Response = {
                status: 204,
                headers: [
                    ("Access-Control-Allow-Origin", "*"),
                    ("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS"),
                    ("Access-Control-Allow-Headers", "Content-Type, Authorization")
                ],
                body: BodyEmpty
             }
             Ok(resp)
        } else {
            match next(ctx) {
                Ok(res) -> {
                     respObj = autoResponse(res)
                     newHeaders = respObj.headers ++ [
                        ("Access-Control-Allow-Origin", "*"),
                        ("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS"),
                        ("Access-Control-Allow-Headers", "Content-Type, Authorization")
                     ]
                     resp: Response = { status: respObj.status, headers: newHeaders, body: respObj.body }
                     Ok(resp)
                }
                Fail(e) -> Fail(e)
            }
        }
    }
}

