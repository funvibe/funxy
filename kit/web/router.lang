package web

import "lib/list" (filter, foldl)
import "lib/string" (stringSplit, stringReplaceAll, stringJoin)
import "lib/map" (mapGet, mapPut)
import "lib/tuple" (fst, snd)

// --- Router ---

type NodeType = Static | Param | Wildcard
type Node = MkNode NodeType String Option<Handler> List<Node>
type Router = MkRouter Map<String, Node> List<Middleware> Handler ((Context, String) -> Result<String, Response>)

fun newRouter() {
    defaultNotFoundHandler = fun(ctx) -> Result<String, Response> {
        Ok(resText("Not Found") |> withStatus(404))
    }
    defaultErrorHandler = fun(ctx, err) -> Result<String, Response> {
        Ok(resText("Internal Server Error") |> withStatus(500))
    }
    MkRouter(%{}, [], defaultNotFoundHandler, defaultErrorHandler)
}

// Router Internal: insertChildSorted
fun insertChildSorted(children, newChild) {
    rank = fun(node) {
        match node {
            MkNode(Static, _, _, _) -> 0
            MkNode(Param, _, _, _) -> 1
            MkNode(Wildcard, _, _, _) -> 2
        }
    }
    newRank = rank(newChild)
    statics = children |> filter(fun(c) { rank(c) == 0 })
    params = children |> filter(fun(c) { rank(c) == 1 })
    wildcards = children |> filter(fun(c) { rank(c) == 2 })
    match newRank {
        0 -> (statics ++ [newChild]) ++ params ++ wildcards
        1 -> statics ++ (params ++ [newChild]) ++ wildcards
        2 -> statics ++ params ++ (wildcards ++ [newChild])
        _ -> children ++ [newChild]
    }
}

// Router Internal: createChain
fun createChain(typ, seg, rest, handler) {
    match rest {
        [] -> MkNode(typ, seg, Some(handler), [])
        [nextSeg, nextRest...] -> {
            nextSegInfo = if len(stringSplit(nextSeg, ":")) > 1 {
                (Param, stringReplaceAll(nextSeg, ":", ""))
            } else if nextSeg == "*" {
                (Wildcard, "_wildcard")
            } else {
                (Static, nextSeg)
            }
            nextType = fst(nextSegInfo)
            nextS = snd(nextSegInfo)
            child = createChain(nextType, nextS, nextRest, handler)
            MkNode(typ, seg, Zero, [child])
        }
    }
}

// Router Internal: findMatchingChild
fun findMatchingChild(children, typ, seg) {
    foldl(fun(acc, child) {
        found = fst(acc)
        others = snd(acc)
        match child {
            MkNode(ct, cs, _, _) -> {
                if ct == typ && cs == seg {
                    (Some(child), others)
                } else {
                    (found, others ++ [child])
                }
            }
        }
    }, (Zero, []), children)
}

// Router Internal: insertNode
fun insertNode(node, segments, handler) {
    match segments {
        [] -> {
            match node {
                MkNode(t, s, _, children) -> MkNode(t, s, Some(handler), children)
            }
        }
        [seg, rest...] -> {
            match node {
                MkNode(typ, s, h, children) -> {
                    nextSegInfo = if len(stringSplit(seg, ":")) > 1 {
                        (Param, stringReplaceAll(seg, ":", ""))
                    } else if seg == "*" {
                        (Wildcard, "_wildcard")
                    } else {
                        (Static, seg)
                    }
                    childType = fst(nextSegInfo)
                    childSeg = snd(nextSegInfo)
                    matchResult = findMatchingChild(children, childType, childSeg)
                    matchOpt = fst(matchResult)
                    otherChildren = snd(matchResult)
                    newChild = match matchOpt {
                        Some(c) -> insertNode(c, rest, handler)
                        Zero -> createChain(childType, childSeg, rest, handler)
                    }
                    newChildren = insertChildSorted(otherChildren, newChild)
                    MkNode(typ, s, h, newChildren)
                }
            }
        }
    }
}

fun addRoute(method, path, handler, r) {
    match r {
        MkRouter(roots, mws, notFoundHandler, errorHandler) -> {
            root = match mapGet(roots, method) {
                Some(n) -> n
                Zero -> MkNode(Static, "/", Zero, [])
            }
            parts = stringSplit(path, "/")
            segments = parts |> filter(fun(s) { s != "" })
            newRoot = insertNode(root, segments, handler)
            newRoots = mapPut(roots, method, newRoot)
            MkRouter(newRoots, mws, notFoundHandler, errorHandler)
        }
    }
}

fun get(path, handler, r) { addRoute("GET", path, handler, r) }
fun post(path, handler, r) { addRoute("POST", path, handler, r) }
fun put(path, handler, r) { addRoute("PUT", path, handler, r) }
fun delete(path, handler, r) { addRoute("DELETE", path, handler, r) }
fun patch(path, handler, r) { addRoute("PATCH", path, handler, r) }
fun options(path, handler, r) { addRoute("OPTIONS", path, handler, r) }

fun use(mw, r) {
    match r {
        MkRouter(roots, mws, notFoundHandler, errorHandler) -> MkRouter(roots, mws ++ [mw], notFoundHandler, errorHandler)
    }
}

fun setNotFoundHandler(r, handler) {
    match r {
        MkRouter(roots, mws, _, errorHandler) -> MkRouter(roots, mws, handler, errorHandler)
    }
}

fun setErrorHandler(r, handler) {
    match r {
        MkRouter(roots, mws, notFoundHandler, _) -> MkRouter(roots, mws, notFoundHandler, handler)
    }
}

// Router Internal: searchChildren
fun searchChildren(children, seg, rest, params) {
    match children {
        [] -> Zero
        [child, otherChildren...] -> {
            match child {
                MkNode(typ, childSeg, _, _) -> {
                    match typ {
                        Static -> {
                            if childSeg == seg {
                                res = matchNode(child, rest, params)
                                match res {
                                    Some(_) -> res
                                    Zero -> searchChildren(otherChildren, seg, rest, params)
                                }
                            } else {
                                searchChildren(otherChildren, seg, rest, params)
                            }
                        }
                        Param -> {
                            newParams = mapPut(params, childSeg, seg)
                            res = matchNode(child, rest, newParams)
                            match res {
                                Some(_) -> res
                                Zero -> searchChildren(otherChildren, seg, rest, params)
                            }
                        }
                        Wildcard -> {
                            suffix = stringJoin([seg] ++ rest, "/")
                            newParams = mapPut(params, childSeg, suffix)
                            match child {
                                MkNode(_, _, handlerOpt, _) -> match handlerOpt {
                                    Some(h) -> Some((h, newParams))
                                    Zero -> Zero
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Router Internal: matchNode
fun matchNode(node, segments, params) {
    match segments {
        [] -> {
            match node {
                MkNode(_, _, handlerOpt, _) -> match handlerOpt {
                    Some(h) -> Some((h, params))
                    Zero -> Zero
                }
            }
        }
        [seg, rest...] -> {
            match node {
                MkNode(_, _, _, children) -> {
                    searchChildren(children, seg, rest, params)
                }
            }
        }
    }
}

fun findRoute(router, method, path) {
    match router {
        MkRouter(roots, _, _, _) -> {
            match mapGet(roots, method) {
                Zero -> Zero
                Some(root) -> {
                    parts = stringSplit(path, "/")
                    segments = parts |> filter(fun(s) { s != "" })
                    result = matchNode(root, segments, %{})
                    result
                }
            }
        }
    }
}
