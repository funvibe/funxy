package ui (*)

import "lib/list" (map, filter, foldl, foldr)
import "lib/string" (stringJoin, stringReplaceAll, stringIndexOf)
import "lib/map" (mapFromRecord, mapItems, mapMerge)
import "lib/tuple" (fst, snd)

// === Types ===

type alias AnyRecord = {}

type VNode =
    Element String Map<String, String> List<SmartResult>
    | Text String
    | Raw String
    | Fragment List<SmartResult>

type alias SmartResult = VNode | BuilderFunc | List<SmartResult>

// Forward declarations/order matters for aliases sometimes
type alias ChildBlock = () -> List<SmartResult>

// Return VNode to match repro structure and potentially avoid cycle issues
type alias BuilderFunc = (UIArg) -> VNode

type alias UIArg = List<SmartResult> | VNode | AnyRecord | ChildBlock | List<List<SmartResult>>


// === Constructors ===

fun text(s) -> SmartResult { Text(s) }
fun raw(s) -> SmartResult { Raw(s) }
fun fragment(children: List<SmartResult>) -> SmartResult { Fragment(children) }

fun showVNode(v: SmartResult) {
    match v {
        n: VNode -> match n {
            Element(tag, _, _) -> "Element(" ++ tag ++ ")"
            Text(s) -> "Text(" ++ s ++ ")"
            Raw(_) -> "Raw(...)"
            Fragment(_) -> "Fragment(...)"
        }
        _ -> "BuilderFunc"
    }
}

// === Internal Helpers ===

fun element(tag, attrs, children: List<SmartResult>) -> VNode {
    attrMap = mapFromRecord(attrs)
    Element(tag, attrMap, children)
}

fun elem(tag, children: List<SmartResult>) -> SmartResult {
    element(tag, {}, children)
}

fun elemA(tag, attrs, children: List<SmartResult>) -> SmartResult {
    element(tag, attrs, children)
}

// === Smart Logic ===

fun resolveArg(tag, attrsMap: Map<String, String>, arg: UIArg) -> VNode {
    match arg {
        l: List<SmartResult> -> element(tag, attrsMap, l)

        n: VNode -> element(tag, attrsMap, [n])

        f: ChildBlock -> element(tag, attrsMap, f())

        r -> {
            newMap = mapFromRecord(r)
            merged = mapMerge(attrsMap, newMap)
            createBuilderFromMap(tag, merged)
        }
    }
}

fun createBuilderFromMap(tag, attrsMap: Map<String, String>) -> BuilderFunc {
    fun(arg: UIArg) -> VNode {
        resolveArg(tag, attrsMap, arg)
    }
}

fun createBuilder(tag, initialAttrs) -> BuilderFunc {
    fun(arg: UIArg) -> VNode {
        initialMap: Map<String, String> = mapFromRecord(initialAttrs)
        resolveArg(tag, initialMap, arg)
    }
}

fun isListType(v) {
    t = show(getType(v))
    match stringIndexOf(t, "List") {
        Some(_) -> true
        _ -> false
    }
}

// Helper to call block dynamicallly (bypassing pattern match limitations)
fun callBlock(f: ChildBlock) -> SmartResult {
    f()
}

fun smartElem(tag, ...args: UIArg) -> SmartResult {
    match args {
        // Single argument case
        [arg] -> match arg {
            l: List<SmartResult> -> elem(tag, l)
            n: VNode -> elem(tag, [n])
            // Try to match ChildBlock explicitly.
            f: ChildBlock -> elem(tag, f())

            // Assume anything else is a Record (attrs)
            r -> createBuilder(tag, r)
        }

        // Two arguments case: div(attrs, children) or div(attrs) { block }
        [attrs, children] -> {
            if isListType(children) {
                // It is a list at runtime. Match to satisfy Analyzer.
                match children {
                    l: List<SmartResult> -> elemA(tag, attrs, l)
                    _ -> panic("expected list")
                }
            } else {
                match children {
                    n: VNode -> elemA(tag, attrs, [n])
                    f -> {
                         // Check if block returns list or single item
                         res = callBlock(f)
                         childrenList = if isListType(res) {
                             match res {
                                 l: List<SmartResult> -> l
                                 _ -> [res] // Fallback (should be covered by isListType)
                             }
                         } else {
                             [res]
                         }
                         elemA(tag, attrs, childrenList)
                    }
                }
            }
        }

        _ -> panic("invalid argument count for " ++ tag ++ ": " ++ show(len(args)))
    }
}

fun smartVoidElem(tag, ...args: UIArg) -> SmartResult {
    match args {
        [attrs] -> voidElemA(tag, attrs)
        [] -> voidElem(tag)
        _ -> panic("void tag " ++ tag ++ " expects optional attrs only")
    }
}

// === Tags ===

fun voidElem(tag) -> SmartResult {
    element(tag, {}, [])
}

fun voidElemA(tag, attrs) -> SmartResult {
    element(tag, attrs, [])
}

// Standard Tags

fun html(...args: UIArg) -> SmartResult { smartElem("html", ...args) }
fun head(...args: UIArg) -> SmartResult { smartElem("head", ...args) }
fun body(...args: UIArg) -> SmartResult { smartElem("body", ...args) }
fun title(...args: UIArg) -> SmartResult { smartElem("title", ...args) }
fun style(...args: UIArg) -> SmartResult { smartElem("style", ...args) }
fun script(...args: UIArg) -> SmartResult { smartElem("script", ...args) }

// Void tags (modified to accept attrs optionally)
fun meta(...args: UIArg) -> SmartResult { smartVoidElem("meta", ...args) }
fun link(...args: UIArg) -> SmartResult { smartVoidElem("link", ...args) }
fun img(...args: UIArg) -> SmartResult { smartVoidElem("img", ...args) }
fun input(...args: UIArg) -> SmartResult { smartVoidElem("input", ...args) }
fun hr(...args: UIArg) -> SmartResult { smartVoidElem("hr", ...args) }
fun br(...args: UIArg) -> SmartResult { smartVoidElem("br", ...args) }

// Semantic tags
fun header(...args: UIArg) -> SmartResult { smartElem("header", ...args) }
fun footer(...args: UIArg) -> SmartResult { smartElem("footer", ...args) }
fun tagMain(...args: UIArg) -> SmartResult { smartElem("main", ...args) }
fun nav(...args: UIArg) -> SmartResult { smartElem("nav", ...args) }
fun section(...args: UIArg) -> SmartResult { smartElem("section", ...args) }
fun article(...args: UIArg) -> SmartResult { smartElem("article", ...args) }
fun aside(...args: UIArg) -> SmartResult { smartElem("aside", ...args) }

// Common tags
fun div(...args: UIArg) -> SmartResult { smartElem("div", ...args) }
fun span(...args: UIArg) -> SmartResult { smartElem("span", ...args) }
fun p(...args: UIArg) -> SmartResult { smartElem("p", ...args) }
fun h1(...args: UIArg) -> SmartResult { smartElem("h1", ...args) }
fun h2(...args: UIArg) -> SmartResult { smartElem("h2", ...args) }
fun h3(...args: UIArg) -> SmartResult { smartElem("h3", ...args) }
fun h4(...args: UIArg) -> SmartResult { smartElem("h4", ...args) }
fun h5(...args: UIArg) -> SmartResult { smartElem("h5", ...args) }
fun h6(...args: UIArg) -> SmartResult { smartElem("h6", ...args) }
fun a(...args: UIArg) -> SmartResult { smartElem("a", ...args) }
fun button(...args: UIArg) -> SmartResult { smartElem("button", ...args) }
fun label(...args: UIArg) -> SmartResult { smartElem("label", ...args) }
fun ul(...args: UIArg) -> SmartResult { smartElem("ul", ...args) }
fun ol(...args: UIArg) -> SmartResult { smartElem("ol", ...args) }
fun li(...args: UIArg) -> SmartResult { smartElem("li", ...args) }
fun form(...args: UIArg) -> SmartResult { smartElem("form", ...args) }
fun textarea(...args: UIArg) -> SmartResult { smartElem("textarea", ...args) }
fun select(...args: UIArg) -> SmartResult { smartElem("select", ...args) }
fun option(...args: UIArg) -> SmartResult { smartElem("option", ...args) }

// Tables
fun table(...args: UIArg) -> SmartResult { smartElem("table", ...args) }
fun tr(...args: UIArg) -> SmartResult { smartElem("tr", ...args) }
fun td(...args: UIArg) -> SmartResult { smartElem("td", ...args) }
fun th(...args: UIArg) -> SmartResult { smartElem("th", ...args) }
fun thead(...args: UIArg) -> SmartResult { smartElem("thead", ...args) }
fun tbody(...args: UIArg) -> SmartResult { smartElem("tbody", ...args) }

// Aliases for explicit attrs (backward compatibility/explicit usage)


// HTML5 DOCTYPE helper
fun html5(arg: UIArg) -> SmartResult {
    Fragment([
        Raw("<!DOCTYPE html>"),
        html(arg)
    ])
}

// === Rendering ===

fun renderAttr(k, v) {
    // Special handling for reserved keywords
    htmlKey = if k == "htmlFor" {
        "for"
    } else if k == "htmlType" {
        "type"
    } else {
        stringReplaceAll(k, "_", "-")
    }
    // Handle boolean attributes
    if v == "true" {
            " " ++ htmlKey
    } else if v == "false" {
            ""
    } else {
        " " ++ htmlKey ++ "=\"" ++ v ++ "\""
    }
}

fun render(node: SmartResult) -> String {
    match node {
        v: VNode -> match v {
            Element(tag, attrs, children) -> {
                attrList = attrs
                    |> mapItems
                    |> map(fun(pair) {
                        k = fst(pair)
                        val = snd(pair)
                        renderAttr(k, val)
                    })

                attrStr = stringJoin(attrList, "")

                childrenStrList = children |> map(render)
                childrenStr = stringJoin(childrenStrList, "")

                result = if isVoidTag(tag) {
                    "<" ++ tag ++ attrStr ++ " />"
                } else {
                    "<" ++ tag ++ attrStr ++ ">" ++ childrenStr ++ "</" ++ tag ++ ">"
                }
                result
            }
            Text(s) -> escapeHtml(s)
            Raw(s) -> s
            Fragment(children) -> {
                strList = children |> map(render)
                stringJoin(strList, "")
            }
        }
        l: List<SmartResult> -> {
            strList = l |> map(render)
            stringJoin(strList, "")
        }
        _ -> ""
    }
}

fun isVoidTag(tag) {
    tag == "img" || tag == "input" || tag == "br" || tag == "hr" ||
    tag == "meta" || tag == "link"
}

fun replace(old, new, s) {
    stringReplaceAll(s, old, new)
}

fun escapeHtml(s) {
    s |> replace("&", "&amp;")
      |> replace("<", "&lt;")
      |> replace(">", "&gt;")
      |> replace("\"", "&quot;")
      |> replace("'", "&#39;")
}
