package ext

import "fmt"

// HelpersTemplate returns the Go source code for runtime conversion helpers.
// This file is included in every generated project — it provides the bridge
// between Funxy evaluator.Object types and native Go types.
func HelpersTemplate(funxyModulePath string) string {
	// Determines import path for pkg/ext.
	// For local build: "github.com/funvibe/funxy/pkg/ext"
	// For released build: "github.com/funvibe/funxy/pkg/ext"
	importPath := funxyModulePath + "/pkg/ext"

	return fmt.Sprintf(`// Code generated by funxy ext codegen. DO NOT EDIT.
package main

import (
	"fmt"
	"reflect"
	"sort"

	ext "%s"
)

// Suppress unused import warnings
var _ = reflect.Map
var _ = sort.Strings

// --- Funxy → Go conversions ---

func toGoInt(obj ext.Object) (int, error) {
	switch v := obj.(type) {
	case *ext.Integer:
		return int(v.Value), nil
	case *ext.Float:
		return int(v.Value), nil
	default:
		return 0, fmt.Errorf("expected Int, got %%s", obj.Type())
	}
}

func toGoInt64(obj ext.Object) (int64, error) {
	switch v := obj.(type) {
	case *ext.Integer:
		return v.Value, nil
	case *ext.Float:
		return int64(v.Value), nil
	default:
		return 0, fmt.Errorf("expected Int, got %%s", obj.Type())
	}
}

func toGoFloat(obj ext.Object) (float64, error) {
	switch v := obj.(type) {
	case *ext.Float:
		return v.Value, nil
	case *ext.Integer:
		return float64(v.Value), nil
	default:
		return 0, fmt.Errorf("expected Float, got %%s", obj.Type())
	}
}

func toGoBool(obj ext.Object) (bool, error) {
	switch v := obj.(type) {
	case *ext.Boolean:
		return v.Value, nil
	default:
		return false, fmt.Errorf("expected Bool, got %%s", obj.Type())
	}
}

func toGoString(obj ext.Object) (string, error) {
	switch v := obj.(type) {
	case *ext.List:
		return ext.ListToString(v), nil
	case *ext.HostObject:
		if s, ok := v.Value.(string); ok {
			return s, nil
		}
		return fmt.Sprintf("%%v", v.Value), nil
	default:
		return "", fmt.Errorf("expected String, got %%s", obj.Type())
	}
}

func toGoBytes(obj ext.Object) ([]byte, error) {
	switch v := obj.(type) {
	case *ext.Bytes:
		return v.ToSlice(), nil
	case *ext.List:
		if ext.IsStringList(v) {
			return []byte(ext.ListToString(v)), nil
		}
		return nil, fmt.Errorf("expected Bytes, got List")
	case *ext.HostObject:
		if b, ok := v.Value.([]byte); ok {
			return b, nil
		}
		return nil, fmt.Errorf("expected Bytes, got HostObject<%%T>", v.Value)
	default:
		return nil, fmt.Errorf("expected Bytes, got %%s", obj.Type())
	}
}

func toGoAny(obj ext.Object) (interface{}, error) {
	switch v := obj.(type) {
	case *ext.Integer:
		return int(v.Value), nil
	case *ext.Float:
		return v.Value, nil
	case *ext.Boolean:
		return v.Value, nil
	case *ext.Nil:
		return nil, nil
	case *ext.List:
		if ext.IsStringList(v) {
			return ext.ListToString(v), nil
		}
		elements := v.ToSlice()
		result := make([]interface{}, len(elements))
		for i, el := range elements {
			val, err := toGoAny(el)
			if err != nil {
				return nil, err
			}
			result[i] = val
		}
		return result, nil
	case *ext.DataInstance:
		// Convert DataInstance to map[string]interface{}
		result := make(map[string]interface{})
		// Fields are positional, but we might want to expose them if we knew names.
		// For now, exposing as "name" and "fields"
		result["_name"] = v.Name
		fields := make([]interface{}, len(v.Fields))
		for i, f := range v.Fields {
			val, err := toGoAny(f)
			if err != nil {
				return nil, err
			}
			fields[i] = val
		}
		result["_fields"] = fields
		return result, nil
	case *ext.Map:
		items := v.Items()
		result := make(map[interface{}]interface{})
		for _, item := range items {
			key, err := toGoAny(item.Key)
			if err != nil {
				return nil, err
			}
			val, err := toGoAny(item.Value)
			if err != nil {
				return nil, err
			}
			// Go map keys must be comparable. If key is slice/map, this will panic at runtime.
			// We trust the user knows what they are doing or we accept the panic/error.
			// Ideally we should check comparable.
			result[key] = val
		}
		return result, nil
	case *ext.Bytes:
		return v.ToSlice(), nil
	case *ext.HostObject:
		return v.Value, nil
	default:
		return obj, nil
	}
}

func toGoError(obj ext.Object) (error, error) {
	switch v := obj.(type) {
	case *ext.Nil:
		return nil, nil
	case *ext.Error:
		return fmt.Errorf("%%s", v.Message), nil
	case *ext.HostObject:
		if e, ok := v.Value.(error); ok {
			return e, nil
		}
		return nil, fmt.Errorf("expected error, got HostObject<%%T>", v.Value)
	default:
		return nil, fmt.Errorf("expected error, got %%s", obj.Type())
	}
}

func toGoContext(obj ext.Object) (interface{}, error) {
	switch v := obj.(type) {
	case *ext.HostObject:
		return v.Value, nil
	default:
		return nil, fmt.Errorf("expected context.Context (HostObject), got %%s", obj.Type())
	}
}

// toGoHost extracts a value of type T from a HostObject.
func toGoHost[T any](obj ext.Object) (T, error) {
	var zero T

	// 1. Try direct HostObject extraction
	if v, ok := obj.(*ext.HostObject); ok {
		if val, ok := v.Value.(T); ok {
			return val, nil
		}
		// 1b. If T is a value type but HostObject holds *T, dereference the pointer.
		// This happens when constructors return *T but callees expect T.
		if reflect.TypeOf(v.Value) != nil && reflect.TypeOf(v.Value).Kind() == reflect.Ptr {
			elem := reflect.ValueOf(v.Value).Elem()
			if !elem.IsZero() || elem.IsValid() {
				if val, ok := elem.Interface().(T); ok {
					return val, nil
				}
			}
		}
	}

	// 2. Handle nil
	if _, ok := obj.(*ext.Nil); ok {
		return zero, nil
	}

	// 3. Try primitive conversion via reflection (for named types like time.Duration)
	targetType := reflect.TypeOf(zero)
	// If T is interface{}, targetType is nil. But toGoHost isn't used for interface{} anymore (toGoAny is).
	// If T is a struct/pointer, targetType is valid.
	if targetType != nil {
		switch targetType.Kind() {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			if i, err := toGoInt64(obj); err == nil {
				return reflect.ValueOf(i).Convert(targetType).Interface().(T), nil
			}
		case reflect.Float32, reflect.Float64:
			if f, err := toGoFloat(obj); err == nil {
				return reflect.ValueOf(f).Convert(targetType).Interface().(T), nil
			}
		case reflect.String:
			if s, err := toGoString(obj); err == nil {
				return reflect.ValueOf(s).Convert(targetType).Interface().(T), nil
			}
		case reflect.Bool:
			if b, err := toGoBool(obj); err == nil {
				return reflect.ValueOf(b).Convert(targetType).Interface().(T), nil
			}
		}
	}

	// Fallback error
	if v, ok := obj.(*ext.HostObject); ok {
		return zero, fmt.Errorf("expected %%T, got HostObject<%%T>", zero, v.Value)
	}
	return zero, fmt.Errorf("expected %%T, got %%s", zero, obj.Type())
}

// toGoHostPtr extracts a pointer value of type *T from a HostObject.
func toGoHostPtr[T any](obj ext.Object) (*T, error) {
	switch v := obj.(type) {
	case *ext.HostObject:
		if val, ok := v.Value.(*T); ok {
			return val, nil
		}
		return nil, fmt.Errorf("expected *%%T, got HostObject<%%T>", new(T), v.Value)
	case *ext.Nil:
		return nil, nil
	default:
		return nil, fmt.Errorf("expected HostObject, got %%s", obj.Type())
	}
}

// toGoSlice converts a Funxy List to a Go slice of type []T.
func toGoSlice[T any](obj ext.Object) ([]T, error) {
	switch v := obj.(type) {
	case *ext.List:
		elements := v.ToSlice()
		result := make([]T, len(elements))
		for i, el := range elements {
			val, err := toGoHost[T](el)
			
			// Recursive check: if T is interface{}, use toGoAny
			var zero T
			if _, isAny := any(&zero).(*interface{}); isAny {
				anyVal, anyErr := toGoAny(el)
				if anyErr != nil {
					return nil, anyErr
				}
				if v, ok := anyVal.(T); ok {
					result[i] = v
					continue
				}
			}
			
			if err != nil {
				// Try basic conversions if T is int/string etc and el is not HostObject
				// This handles List<Int> -> []int
				if vInt, ok := el.(*ext.Integer); ok {
					if _, isInt := any(result[i]).(int); isInt {
						// This is tricky with generics. We can't cast T to int directly.
						// We use any() intermediate.
						// any(result)[i] is not addressable directly like this.
						// Instead we assign to result[i] by casting the value.
						result[i] = any(int(vInt.Value)).(T)
						continue
					}
				}
				// ... (more primitive checks could go here, but strict typing is preferred)
				return nil, err
			}
			result[i] = val
		}
		return result, nil
	case *ext.Nil:
		return nil, nil
	case *ext.HostObject:
		if s, ok := v.Value.([]T); ok {
			return s, nil
		}
		return nil, fmt.Errorf("expected List, got HostObject<%%T>", v.Value)
	default:
		return nil, fmt.Errorf("expected List, got %%s", obj.Type())
	}
}

// toGoMap converts a Funxy Map to a Go map[K]V.
func toGoMap[K comparable, V any](obj ext.Object) (map[K]V, error) {
	switch v := obj.(type) {
	case *ext.Map:
		items := v.Items()
		result := make(map[K]V)
		for _, item := range items {
			// Convert key
			keyVal, err := toGoHost[K](item.Key) 
			// Handle primitives for keys (HostObject check inside toGoHost might fail for Integer)
			if err != nil {
				// Fallback for primitives
				if kInt, ok := item.Key.(*ext.Integer); ok {
					if _, isInt := any(keyVal).(int); isInt {
						keyVal = any(int(kInt.Value)).(K)
						err = nil
					}
				} else if kStr, ok := item.Key.(*ext.List); ok { // String is List<Char>
					// Need toString...
					if s, errStr := toGoString(kStr); errStr == nil {
						if _, isStr := any(keyVal).(string); isStr {
							keyVal = any(s).(K)
							err = nil
						}
					}
				}
			}
		if err != nil {
			return nil, fmt.Errorf("map key: %%v", err)
		}

			// Convert value
			valVal, err := toGoHost[V](item.Value)
			if _, isAny := any(new(V)).(*interface{}); isAny {
				anyVal, anyErr := toGoAny(item.Value)
				if anyErr != nil {
					return nil, anyErr
				}
				if v, ok := anyVal.(V); ok {
					result[keyVal] = v
					continue
				}
			}
			
		if err != nil {
			return nil, fmt.Errorf("map value: %%v", err)
		}
			result[keyVal] = valVal
		}
		return result, nil
	case *ext.HostObject:
		if m, ok := v.Value.(map[K]V); ok {
			return m, nil
		}
		return nil, fmt.Errorf("expected Map, got HostObject<%%T>", v.Value)
	case *ext.Nil:
		return nil, nil
	default:
		return nil, fmt.Errorf("expected Map, got %%s", obj.Type())
	}
}

// --- Go → Funxy conversions ---

func toFunxy(val interface{}) ext.Object {
	return ext.ToFunxy(val)
}

// newErr creates a Funxy error object.
func newErr(format string, args ...interface{}) ext.Object {
	return ext.NewError(format, args...)
}

// --- Result<String, T> helpers ---

func makeResultOk(val ext.Object) ext.Object {
	return ext.MakeResultOk(val)
}

func makeResultErr(msg string) ext.Object {
	return ext.MakeResultFail(msg)
}
`, importPath)
}
