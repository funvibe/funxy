package ext

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// GenerateStubs creates .d.lang declaration files for ext/* modules.
// These files provide type information for LSP support (autocompletion,
// type checking) without requiring a full build.
//
// Files are written to <projectDir>/.funxy/ext/<modName>.d.lang
func GenerateStubs(cfg *Config, result *InspectResult, projectDir string) error {
	stubDir := filepath.Join(projectDir, ".funxy", "ext")
	if err := os.MkdirAll(stubDir, 0o755); err != nil {
		return fmt.Errorf("creating stub directory: %w", err)
	}

	// Group bindings by module
	groups := make(map[string][]*ResolvedBinding)
	depForModule := make(map[string]*Dep)
	for _, b := range result.Bindings {
		modName := b.Dep.ExtModuleName()
		groups[modName] = append(groups[modName], b)
		dep := b.Dep
		depForModule[modName] = &dep
	}

	for modName, bindings := range groups {
		content := generateStubFile(modName, depForModule[modName], bindings)
		stubPath := filepath.Join(stubDir, modName+".d.lang")
		if err := os.WriteFile(stubPath, []byte(content), 0o644); err != nil {
			return fmt.Errorf("writing %s: %w", stubPath, err)
		}
	}

	// Write a .gitignore for the .funxy directory if it doesn't exist
	gitignorePath := filepath.Join(projectDir, ".funxy", ".gitignore")
	if _, err := os.Stat(gitignorePath); os.IsNotExist(err) {
		gitignoreContent := "# Auto-generated by funxy ext\next/\next-cache/\n"
		if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0o644); err != nil {
			// Non-fatal
			_ = err
		}
	}

	return nil
}

// generateStubFile creates the content of a .d.lang file for one ext module.
func generateStubFile(modName string, dep *Dep, bindings []*ResolvedBinding) string {
	var buf strings.Builder

	// Header
	buf.WriteString(fmt.Sprintf("// Declaration file for ext/%s\n", modName))
	if dep != nil {
		buf.WriteString(fmt.Sprintf("// Go package: %s", dep.Pkg))
		if dep.Version != "" && dep.Version != "latest" {
			buf.WriteString(fmt.Sprintf(" %s", dep.Version))
		}
		buf.WriteString("\n")
	}
	buf.WriteString("// Auto-generated by funxy ext stubs. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// Usage: import \"ext/%s\"\n\n", modName))

	buf.WriteString("// Use `package <name> (*)` if you need to import this file as a module\n\n")

	for _, b := range bindings {
		if b.TypeBinding != nil {
			generateTypeStubs(&buf, b)
		}
		if b.FuncBinding != nil {
			generateFuncStub(&buf, b)
		}
		if b.ConstBinding != nil {
			generateConstStub(&buf, b)
		}
	}

	return buf.String()
}

// generateTypeStubs generates stub declarations for a type binding's methods.
func generateTypeStubs(buf *strings.Builder, b *ResolvedBinding) {
	tb := b.TypeBinding

	// Comment describing the Go type
	buf.WriteString(fmt.Sprintf("// --- %s (%s.%s) ---\n\n",
		b.Spec.As, ImportAlias(b.GoPackagePath), tb.GoName))

	for _, method := range tb.Methods {
		sig := method.Signature
		skipCtx := b.Spec.SkipContext && sig.HasContextParam
		errorToResult := b.Spec.ErrorToResult
		chainResult := b.Spec.ChainResult
		if chainResult == "" {
			chainResult = method.AutoChainMethod
		}

		// Build parameter list
		params := []string{"self: HostObject"}
		for i, p := range sig.Params {
			if skipCtx && i == 0 && sig.HasContextParam {
				continue
			}
			paramName := p.Name
			if paramName == "" {
				paramName = fmt.Sprintf("arg%d", i)
			}
			// Sanitize reserved words
			paramName = sanitizeParamName(paramName)

			paramType := p.Type.FunxyType
			if p.IsVariadic {
				params = append(params, fmt.Sprintf("%s: ...%s", paramName, paramType))
			} else {
				params = append(params, fmt.Sprintf("%s: %s", paramName, paramType))
			}
		}

		// Build return type — chain_result only applies to single non-error returns
		useChain := chainResult != "" && len(sig.Results) == 1 && !sig.HasErrorReturn
		returnType := buildReturnTypeString(sig, errorToResult, useChain)

		// Write declaration
		buf.WriteString(fmt.Sprintf("fun %s(%s) -> %s\n",
			method.FunxyName, strings.Join(params, ", "), returnType))
	}

	// Constructor
	if b.Spec.Constructor && tb.IsStruct && len(tb.Fields) > 0 {
		buf.WriteString("\n// Constructor\n")
		var fieldDecls []string
		for _, field := range tb.Fields {
			fieldDecls = append(fieldDecls, fmt.Sprintf("%s: %s", field.FunxyName, field.Type.FunxyType))
		}
		buf.WriteString(fmt.Sprintf("fun %s(record: { %s }) -> HostObject\n",
			b.Spec.As, strings.Join(fieldDecls, ", ")))
	}

	// Field getters
	if tb.IsStruct && len(tb.Fields) > 0 {
		buf.WriteString("\n// Fields\n")
		for _, field := range tb.Fields {
			funxyName := b.Spec.As + ucFirst(field.GoName)
			buf.WriteString(fmt.Sprintf("fun %s(self: HostObject) -> %s\n",
				funxyName, field.Type.FunxyType))
		}
	}

	buf.WriteString("\n")
}

// generateConstStub generates a stub declaration for a constant binding.
func generateConstStub(buf *strings.Builder, b *ResolvedBinding) {
	cb := b.ConstBinding
	buf.WriteString(fmt.Sprintf("// %s.%s (constant)\n", ImportAlias(b.GoPackagePath), cb.GoName))
	buf.WriteString(fmt.Sprintf("// %s : %s\n\n", b.Spec.As, cb.Type.FunxyType))
}

// generateFuncStub generates a stub declaration for a function binding.
func generateFuncStub(buf *strings.Builder, b *ResolvedBinding) {
	fb := b.FuncBinding
	sig := fb.Signature
	skipCtx := b.Spec.SkipContext && sig.HasContextParam
	errorToResult := b.Spec.ErrorToResult

	// Comment
	buf.WriteString(fmt.Sprintf("// %s.%s\n", ImportAlias(b.GoPackagePath), fb.GoName))

	// Build parameter list
	var params []string
	for i, p := range sig.Params {
		if skipCtx && i == 0 && sig.HasContextParam {
			continue
		}
		paramName := p.Name
		if paramName == "" {
			paramName = fmt.Sprintf("arg%d", i)
		}
		paramName = sanitizeParamName(paramName)

		paramType := p.Type.FunxyType
		if p.IsVariadic {
			params = append(params, fmt.Sprintf("%s: ...%s", paramName, paramType))
		} else {
			params = append(params, fmt.Sprintf("%s: %s", paramName, paramType))
		}
	}

	returnType := buildReturnTypeString(sig, errorToResult, false)

	buf.WriteString(fmt.Sprintf("fun %s(%s) -> %s\n",
		b.Spec.As, strings.Join(params, ", "), returnType))
	buf.WriteString("\n")
}

// buildReturnTypeString creates the Funxy return type string from a signature.
func buildReturnTypeString(sig *FuncSignature, errorToResult, isChained bool) string {
	if isChained {
		if errorToResult {
			return "Result<String, HostObject>"
		}
		return "HostObject"
	}

	numResults := len(sig.Results)
	switch {
	case numResults == 0:
		return "Nil"

	case numResults == 1 && !sig.HasErrorReturn:
		return sig.Results[0].Type.FunxyType

	case numResults == 1 && sig.HasErrorReturn:
		if errorToResult {
			return "Result<String, Nil>"
		}
		return "Nil"

	case numResults == 2 && sig.HasErrorReturn:
		innerType := sig.Results[0].Type.FunxyType
		if errorToResult {
			return fmt.Sprintf("Result<String, %s>", innerType)
		}
		return innerType

	default:
		// Multiple returns → describe as Tuple
		var types []string
		for _, r := range sig.Results {
			if sig.HasErrorReturn && r.Type.Kind == GoTypeError {
				continue
			}
			types = append(types, r.Type.FunxyType)
		}
		if len(types) == 1 {
			if errorToResult {
				return fmt.Sprintf("Result<String, %s>", types[0])
			}
			return types[0]
		}
		// No native Tuple syntax in declarations; use comment
		return fmt.Sprintf("(%s)", strings.Join(types, ", "))
	}
}

// sanitizeParamName replaces Go parameter names that conflict with Funxy keywords.
func sanitizeParamName(name string) string {
	reserved := map[string]bool{
		"if": true, "else": true, "match": true, "fun": true,
		"let": true, "type": true, "import": true, "true": true,
		"false": true, "nil": true, "in": true, "do": true,
		"where": true, "then": true,
	}
	if reserved[name] {
		return name + "_"
	}
	return name
}
