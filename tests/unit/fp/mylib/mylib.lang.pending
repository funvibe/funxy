package mylib (
    Text, MkText, getText,
    Score, MkScore, getScore,
    Item, MkItem, itemName, itemValue,
    Counter, MkCounter, counterValue, counterLabel,
    stringify, display, format,
    combineText, combineScore, combineCounter,
    choose,
    sumInts, sumScores, sumCounters
)

// =============================================
// TYPES
// =============================================

type Text = MkText String

fun getText(t: Text) -> String {
    match t { MkText s -> s }
}

type Score = MkScore Int

fun getScore(s: Score) -> Int {
    match s { MkScore n -> n }
}

type Item = MkItem String Int

fun itemName(i: Item) -> String {
    match i { MkItem(n, _) -> n }
}

fun itemValue(i: Item) -> Int {
    match i { MkItem(_, v) -> v }
}

type Counter = MkCounter Int String

fun counterValue(c: Counter) -> Int {
    match c { MkCounter(v, _) -> v }
}

fun counterLabel(c: Counter) -> String {
    match c { MkCounter(_, l) -> l }
}

// =============================================
// TRAIT: Stringify
// =============================================

trait Stringify<T> {
    fun stringify(x: T) -> String
}

instance Stringify Text {
    fun stringify(x: Text) -> String {
        "Text(" ++ getText(x) ++ ")"
    }
}

instance Stringify Int {
    fun stringify(x: Int) -> String {
        "Int(" ++ show(x) ++ ")"
    }
}

instance Stringify Counter {
    fun stringify(x: Counter) -> String {
        counterLabel(x) ++ "=" ++ show(counterValue(x))
    }
}

// =============================================
// TRAIT: Showable (base) and Printable (child)
// =============================================

trait Showable<T> {
    fun display(x: T) -> String
}

trait Printable<T> : Showable<T> {
    fun format(x: T) -> String
}

instance Showable Item {
    fun display(x: Item) -> String {
        itemName(x) ++ ":" ++ show(itemValue(x))
    }
}

instance Printable Item {
    fun format(x: Item) -> String {
        "[" ++ display(x) ++ "]"
    }
}

// =============================================
// OPERATORS: Semigroup (<>) and UserOpChoose (<|>)
// =============================================

instance Semigroup Text {
    operator (<>)(a: Text, b: Text) -> Text {
        MkText(getText(a) ++ getText(b))
    }
}

instance Semigroup Score {
    operator (<>)(a: Score, b: Score) -> Score {
        MkScore(getScore(a) + getScore(b))
    }
}

instance UserOpChoose Score {
    operator (<|>)(a: Score, b: Score) -> Score {
        if getScore(a) >= getScore(b) { a } else { b }
    }
}

instance Semigroup Counter {
    operator (<>)(a: Counter, b: Counter) -> Counter {
        MkCounter(counterValue(a) + counterValue(b), counterLabel(a) ++ "+" ++ counterLabel(b))
    }
}

// =============================================
// TRAIT: Summable with nullary method
// =============================================

trait Summable<T> {
    fun add(a: T, b: T) -> T
    fun zero() -> T
}

instance Summable Int {
    fun add(a: Int, b: Int) -> Int { a + b }
    fun zero() -> Int { 0 }
}

instance Summable Score {
    fun add(a: Score, b: Score) -> Score {
        MkScore(getScore(a) + getScore(b))
    }
    fun zero() -> Score { MkScore(0) }
}

instance Summable Counter {
    fun add(a: Counter, b: Counter) -> Counter {
        a <> b
    }
    fun zero() -> Counter { MkCounter(0, "zero") }
}

// Helper functions for summing
fun sumInts(list: List<Int>) -> Int {
    match list {
        [] -> (zero() : Int)
        [x, xs...] -> add(x, sumInts(xs))
    }
}

fun sumScores(list: List<Score>) -> Score {
    match list {
        [] -> (zero() : Score)
        [x, xs...] -> add(x, sumScores(xs))
    }
}

fun sumCounters(list: List<Counter>) -> Counter {
    match list {
        [] -> (zero() : Counter)
        [x, xs...] -> add(x, sumCounters(xs))
    }
}

// =============================================
// HELPER FUNCTIONS
// =============================================

fun combineText(a: Text, b: Text) -> Text {
    a <> b
}

fun combineScore(a: Score, b: Score) -> Score {
    a <> b
}

fun combineCounter(a: Counter, b: Counter) -> Counter {
    a <> b
}

fun choose(a: Score, b: Score) -> Score {
    a <|> b
}

