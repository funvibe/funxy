import "lib/test" (*)

// =============================================
// Custom FP Types and Laws Tests
// Tests that user-defined types satisfy FP laws
// =============================================

// =============================================
// Custom Maybe type (different from built-in Option)
// =============================================

type Maybe<a> = Just a | Nothing

instance Functor Maybe {
    fun fmap(f: (a) -> b, ma: Maybe<a>) -> Maybe<b> {
        match ma {
            Nothing -> Nothing
            Just(val) -> Just(f(val))
        }
    }
}

instance Applicative Maybe {
    fun pure(val: a) -> Maybe<a> { Just(val) }

    operator (<*>)(mf: Maybe<(a) -> b>, ma: Maybe<a>) -> Maybe<b> {
        match mf {
            Nothing -> Nothing
            Just(f) -> fmap(f, ma)
        }
    }
}

instance Monad Maybe {
    operator (>>=)(ma: Maybe<a>, f: (a) -> Maybe<b>) -> Maybe<b> {
        match ma {
            Nothing -> Nothing
            Just(val) -> f(val)
        }
    }
}

instance Semigroup Maybe<a> {
    operator (<>)(lhs: Maybe<a>, rhs: Maybe<a>) -> Maybe<a> {
        match lhs {
            Nothing -> rhs
            Just(_) -> lhs
        }
    }
}

instance Monoid Maybe<a> {
    fun mempty() -> Maybe<a> { Nothing }
}


// =============================================
// Custom Either type (different from built-in Result)
// Either<L, R> - L is "left" (error), R is "right" (success)
// =============================================

type Either<l, r> = Left l | Right r

instance Functor Either<e> {
    fun fmap(f: (a) -> b, ea: Either<e, a>) -> Either<e, b> {
        match ea {
            Left(e) -> Left(e)
            Right(a) -> Right(f(a))
        }
    }
}

instance Applicative Either<e> {
    fun pure(a: a) -> Either<e, a> { Right(a) }

    operator (<*>)(ef: Either<e, (a) -> b>, ea: Either<e, a>) -> Either<e, b> {
        match ef {
            Left(e) -> Left(e)
            Right(f) -> fmap(f, ea)
        }
    }
}

instance Monad Either<e> {
    operator (>>=)(ea: Either<e, a>, f: (a) -> Either<e, b>) -> Either<e, b> {
        match ea {
            Left(e) -> Left(e)
            Right(a) -> f(a)
        }
    }
}

// =============================================
// Custom MyIdentity type (simplest monad)
// =============================================

type MyIdentity<a> = Id a

instance Functor MyIdentity {
    fun fmap(f: (a) -> b, ia: MyIdentity<a>) -> MyIdentity<b> {
        match ia {
            Id(a) -> Id(f(a))
        }
    }
}

instance Applicative MyIdentity {
    fun pure(a: a) -> MyIdentity<a> { Id(a) }

    operator (<*>)(idf: MyIdentity<(a) -> b>, ia: MyIdentity<a>) -> MyIdentity<b> {
        match idf {
            Id(f) -> fmap(f, ia)
        }
    }
}

instance Monad MyIdentity {
    operator (>>=)(ia: MyIdentity<a>, f: (a) -> MyIdentity<b>) -> MyIdentity<b> {
        match ia {
            Id(a) -> f(a)
        }
    }
}

// =============================================
// Helper functions
// =============================================

fun double(x: Int) -> Int { x * 2 }
fun addTen(x: Int) -> Int { x + 10 }

fun maybeDouble(x: Int) -> Maybe<Int> { Just(x * 2) }
fun maybeAddTen(x: Int) -> Maybe<Int> { Just(x + 10) }

fun eitherDouble(x: Int) -> Either<String, Int> { Right(x * 2) }
fun eitherAddTen(x: Int) -> Either<String, Int> { Right(x + 10) }

fun idDouble(x: Int) -> MyIdentity<Int> { Id(x * 2) }
fun idAddTen(x: Int) -> MyIdentity<Int> { Id(x + 10) }

// =============================================
// Maybe Laws Tests
// =============================================

testRun("Maybe Functor MyIdentity", fun() -> {
    x = Just(42)
    result = fmap(id, x)
    assert(result == x)
})

testRun("Maybe Functor Composition", fun() -> {
    x = Just(5)
    left = fmap(double ,, addTen, x)
    right = fmap(double, fmap(addTen, x))
    assert(left == right)
})

testRun("Maybe Applicative MyIdentity", fun() -> {
    v = Just(42)
    idFn: Maybe<(Int) -> Int> = pure(id)
    result = idFn <*> v
    assert(result == v)
})

testRun("Maybe Applicative Homomorphism", fun() -> {
    f = double
    x = 21
    left: Maybe<Int> = (pure(f) : Maybe<(Int) -> Int>) <*> pure(x)
    right: Maybe<Int> = pure(f(x))
    assert(left == right)
})

testRun("Maybe Monad Left MyIdentity", fun() -> {
    a = 21
    f = maybeDouble
    left = (pure(a) : Maybe<Int>) >>= f
    right = f(a)
    assert(left == right)
})

testRun("Maybe Monad Right MyIdentity", fun() -> {
    m = Just(42)
    result = m >>= pure
    assert(result == m)
})

testRun("Maybe Monad Associativity", fun() -> {
    m = Just(5)
    f = maybeDouble
    g = maybeAddTen
    left = (m >>= f) >>= g
    right = m >>= fun(x) -> f(x) >>= g
    assert(left == right)
})

testRun("Maybe Semigroup Associativity", fun() -> {
    a = Just(1)
    b = Just(2)
    c = Just(3)
    left = (a <> b) <> c
    right = a <> (b <> c)
    assert(left == right)
})

testRun("Maybe Monoid Left MyIdentity", fun() -> {
    x = Just(42)
    empty: Maybe<Int> = Nothing
    result = empty <> x
    assert(result == x)
})

testRun("Maybe Monoid Right MyIdentity", fun() -> {
    x = Just(42)
    empty: Maybe<Int> = Nothing
    result = x <> empty
    assert(result == x)
})

// =============================================
// Either Laws Tests
// =============================================

testRun("Either Functor MyIdentity - Right", fun() -> {
    x: Either<String, Int> = Right(42)
    result = fmap(id, x)
    assert(result == x)
})

testRun("Either Functor MyIdentity - Left", fun() -> {
    x: Either<String, Int> = Left("error")
    result = fmap(id, x)
    assert(result == x)
})

testRun("Either Functor Composition", fun() -> {
    x: Either<String, Int> = Right(5)
    left = fmap(double ,, addTen, x)
    right = fmap(double, fmap(addTen, x))
    assert(left == right)
})

testRun("Either Monad Left MyIdentity", fun() -> {
    a = 21
    f = eitherDouble
    left = (pure(a) : Either<String, Int>) >>= f
    right = f(a)
    assert(left == right)
})

testRun("Either Monad Right MyIdentity - Right", fun() -> {
    m: Either<String, Int> = Right(42)
    result = m >>= pure
    assert(result == m)
})

testRun("Either Monad Right MyIdentity - Left", fun() -> {
    m: Either<String, Int> = Left("error")
    result = m >>= pure
    assert(result == m)
})

testRun("Either Monad Associativity", fun() -> {
    m: Either<String, Int> = Right(5)
    f = eitherDouble
    g = eitherAddTen
    left = (m >>= f) >>= g
    right = m >>= fun(x) -> f(x) >>= g
    assert(left == right)
})

// =============================================
// MyIdentity Laws Tests
// =============================================

testRun("MyIdentity Functor MyIdentity", fun() -> {
    x = Id(42)
    result = fmap(id, x)
    assert(result == x)
})

testRun("MyIdentity Functor Composition", fun() -> {
    x = Id(5)
    left = fmap(double ,, addTen, x)
    right = fmap(double, fmap(addTen, x))
    assert(left == right)
})

testRun("MyIdentity Applicative MyIdentity", fun() -> {
    v = Id(42)
    idFn: MyIdentity<(Int) -> Int> = pure(id)
    result = idFn <*> v
    assert(result == v)
})

testRun("MyIdentity Monad Left MyIdentity", fun() -> {
    a = 21
    f = idDouble
    left = (pure(a) : MyIdentity<Int>) >>= f
    right = f(a)
    assert(left == right)
})

testRun("MyIdentity Monad Right MyIdentity", fun() -> {
    m = Id(42)
    result = m >>= pure
    assert(result == m)
})

testRun("MyIdentity Monad Associativity", fun() -> {
    m = Id(5)
    f = idDouble
    g = idAddTen
    left = (m >>= f) >>= g
    right = m >>= fun(x) -> f(x) >>= g
    assert(left == right)
})

print("All custom FP laws tests defined")
