// =============================================================================
// Stabilization Test: Nested Structures
// =============================================================================
// Tests parsing of deeply nested and complex structures.
// Parser bugs here often manifest as "unexpected token" or wrong AST structure.

import "lib/test" (testRun, assertEquals, assertTrue, assertSome, assertNone)

// Types must be defined at module level to be usable in tests
type alias NsPoint = { x: Int, y: Int }
type alias NsLine = { start: NsPoint, ends: NsPoint }
type alias NsAddress = { city: String, zip: Int }
type alias NsPerson = { name: String, address: NsAddress }

// =============================================================================
// NESTED LAMBDAS
// =============================================================================

testRun("Nested lambda: simple", \ -> {
    f = \x -> \y -> x + y
    assertEquals(5, f(2)(3), "curried add")
})

testRun("Nested lambda: three levels", \ -> {
    f = \x -> \y -> \z -> x + y + z
    assertEquals(6, f(1)(2)(3), "curried add3")
})

testRun("Nested lambda: with blocks", \ -> {
    f = \x -> {
        \y -> {
            \z -> {
                x + y + z
            }
        }
    }
    assertEquals(6, f(1)(2)(3), "curried with blocks")
})

testRun("Nested lambda: mixed syntax", \ -> {
    f = fun(x) {
        \y -> fun(z) { x * y * z }
    }
    assertEquals(24, f(2)(3)(4), "mixed lambda syntax")
})

testRun("Nested lambda: in list", \ -> {
    fns = [\x -> x + 1, \x -> x * 2, \x -> x ** 2]
    assertEquals(4, fns[0](3), "lambda in list 0")
    assertEquals(6, fns[1](3), "lambda in list 1")
    assertEquals(9, fns[2](3), "lambda in list 2")
})

testRun("Nested lambda: returning lambda from if", \ -> {
    choose = \cond -> if cond { \x -> x + 1 } else { \x -> x * 2 }
    f = choose(true)
    g = choose(false)
    assertEquals(4, f(3), "true branch lambda")
    assertEquals(6, g(3), "false branch lambda")
})

// =============================================================================
// NESTED PATTERN MATCHING
// =============================================================================

testRun("Nested match: in lambda", \ -> {
    f = \opt -> match opt {
        Some(x) -> x * 2
        None -> 0
    }
    assertEquals(10, f(Some(5)), "match in lambda Some")
    assertEquals(0, f(None), "match in lambda None")
})

testRun("Nested match: match in match arm", \ -> {
    f = \outer -> match outer {
        Some(inner) -> match inner {
            Some(x) -> x
            None -> -1
        }
        None -> -2
    }
    assertEquals(42, f(Some(Some(42))), "nested Some Some")
    assertEquals(-1, f(Some(None)), "nested Some None")
    assertEquals(-2, f(None), "nested None")
})

testRun("Nested match: with guards", \ -> {
    classify = \x -> match x {
        n if n < 0 -> "negative"
        n if n == 0 -> "zero"
        n if n < 10 -> "small"
        n if n < 100 -> "medium"
        _ -> "large"
    }
    assertEquals("negative", classify(-5), "guard negative")
    assertEquals("zero", classify(0), "guard zero")
    assertEquals("small", classify(5), "guard small")
    assertEquals("medium", classify(50), "guard medium")
    assertEquals("large", classify(500), "guard large")
})

testRun("Nested match: destructuring nested tuples", \ -> {
    f = \t -> match t {
        ((a, b), (c, d)) -> a + b + c + d
    }
    assertEquals(10, f(((1, 2), (3, 4))), "nested tuple destruct")
})

testRun("Nested match: destructuring nested records", \ -> {
    // Using module-level types NsPoint and NsLine
    lenSq = \line -> {
        dx = line.ends.x - line.start.x
        dy = line.ends.y - line.start.y
        dx ** 2 + dy ** 2
    }

    line = NsLine { start: NsPoint { x: 0, y: 0 }, ends: NsPoint { x: 3, y: 4 } }
    assertEquals(25, lenSq(line), "nested record field access")
})

testRun("Nested match: list patterns", \ -> {
    describe = \list -> match list {
        [] -> "empty"
        [x] -> "single"
        [x, y] -> "pair"
        [x, y, z] -> "triple"
        [h, ...t] -> "many: " ++ show(len(t) + 1)
    }
    assertEquals("empty", describe([]), "list empty")
    assertEquals("single", describe([1]), "list single")
    assertEquals("pair", describe([1, 2]), "list pair")
    assertEquals("triple", describe([1, 2, 3]), "list triple")
    assertEquals("many: 5", describe([1, 2, 3, 4, 5]), "list many")
})

// =============================================================================
// NESTED IF EXPRESSIONS
// =============================================================================

testRun("Nested if: simple", \ -> {
    classify = \n ->
        if n < 0 {
            "negative"
        } else {
            if n == 0 {
                "zero"
            } else {
                "positive"
            }
        }
    assertEquals("negative", classify(-1), "nested if negative")
    assertEquals("zero", classify(0), "nested if zero")
    assertEquals("positive", classify(1), "nested if positive")
})

testRun("Nested if: in both branches", \ -> {
    f = \a -> \b -> {
        if a {
            if b { "both" } else { "only a" }
        } else {
            if b { "only b" } else { "neither" }
        }
    }
    assertEquals("both", f(true)(true), "both true")
    assertEquals("only a", f(true)(false), "only a")
    assertEquals("only b", f(false)(true), "only b")
    assertEquals("neither", f(false)(false), "neither")
})

testRun("Nested if: as expression value", \ -> {
    result = if true {
        if false { 1 } else { 2 }
    } else {
        if true { 3 } else { 4 }
    }
    assertEquals(2, result, "nested if expression")
})

// =============================================================================
// NESTED BLOCKS
// =============================================================================

testRun("Nested blocks: variable scoping", \ -> {
    // Blocks share scope - assignment inside block modifies outer variable
    x = 1
    result = {
        x = 2
        inner = {
            x = 3
            x
        }
        x + inner
    }
    assertEquals(6, result, "nested block result")
    assertEquals(3, x, "x modified by inner block")
})

testRun("Nested blocks: with let", \ -> {
    result = {
        a = 1
        b = {
            c = 2
            d = {
                e = 3
                a + c + e
            }
            d
        }
        b
    }
    assertEquals(6, result, "deeply nested let")
})

// =============================================================================
// NESTED FUNCTION DEFINITIONS
// =============================================================================

testRun("Nested functions: local helper", \ -> {
    fun outer(x) {
        fun inner(y) {
            x + y
        }
        inner(10) + inner(20)
    }
    // outer(5) = inner(10) + inner(20) = (5+10) + (5+20) = 15 + 25 = 40
    assertEquals(40, outer(5), "nested function")
})

testRun("Nested functions: three levels", \ -> {
    fun level1(a) {
        fun level2(b) {
            fun level3(c) {
                a + b + c
            }
            level3(3)
        }
        level2(2)
    }
    assertEquals(6, level1(1), "three level nesting")
})

testRun("Nested functions: cascading calls", \ -> {
    // Note: true mutual recursion between nested functions may require forward declarations
    // Testing cascading nested function calls instead
    fun outer(n) {
        fun helper1(x) { x * 2 }
        fun helper2(x) { helper1(x) + 1 }
        fun helper3(x) { helper2(x) + helper1(x) }
        helper3(n)
    }
    // helper3(5) = helper2(5) + helper1(5) = (5*2+1) + (5*2) = 11 + 10 = 21
    assertEquals(21, outer(5), "cascading nested calls")
})

// =============================================================================
// NESTED DATA STRUCTURES
// =============================================================================

testRun("Nested lists", \ -> {
    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    assertEquals(5, matrix[1][1], "matrix access")
    assertEquals([1, 2, 3], matrix[0], "row access")
})

testRun("Nested tuples", \ -> {
    nested = ((1, 2), (3, (4, 5)))
    assertEquals((1, 2), nested[0], "tuple first")
    assertEquals((4, 5), nested[1][1], "nested tuple access")
})

testRun("Nested records", \ -> {
    // Using module-level types NsAddress and NsPerson
    p = NsPerson {
        name: "Alice",
        address: NsAddress { city: "NYC", zip: 10001 }
    }
    assertEquals("NYC", p.address.city, "nested record field")
    assertEquals(10001, p.address.zip, "nested record zip")
})

testRun("Mixed nesting: list of tuples of Options", \ -> {
    data = [(Some(1), Some(2)), (None, Some(3)), (Some(4), None)]

    sumFirst = \list -> {
        fun go(acc, lst) {
            match lst {
                [] -> acc
                [(opt, _), ...rest] -> match opt {
                    Some(x) -> go(acc + x, rest)
                    None -> go(acc, rest)
                }
            }
        }
        go(0, list)
    }
    assertEquals(5, sumFirst(data), "sum of first elements")
})

// =============================================================================
// COMPLEX MIXED NESTING
// =============================================================================

testRun("Complex: lambda returning match returning lambda", \ -> {
    f = \opt -> match opt {
        Some(x) -> \y -> x + y
        None -> \y -> y * 2
    }

    g = f(Some(10))
    h = f(None)

    assertEquals(15, g(5), "Some branch lambda")
    assertEquals(10, h(5), "None branch lambda")
})

testRun("Complex: if in match in lambda", \ -> {
    f = \opt -> \flag -> match opt {
        Some(x) -> if flag { x * 2 } else { x + 2 }
        None -> if flag { 0 } else { -1 }
    }

    assertEquals(10, f(Some(5))(true), "Some true")
    assertEquals(7, f(Some(5))(false), "Some false")
    assertEquals(0, f(None)(true), "None true")
    assertEquals(-1, f(None)(false), "None false")
})

testRun("Complex: nested everything", \ -> {
    // Using nested Option/List combinations instead of custom Tree type
    // to avoid parser issues with inline ADT definitions

    // Simulate a tree structure using nested lists
    // [[1, 2], [[3], [4, 5]]] represents a tree
    leaf = \x -> [x]
    node = \l -> \r -> [l, r]

    fun sumList(l) {
        match l {
            [] -> 0
            [x] if x >= 0 && x <= 100 -> x  // It's a leaf value
            [left, right, ...rest] -> sumList(left) + sumList(right)
            _ -> 0
        }
    }

    // Simple test with nested lists
    assertEquals(6, 1 + 2 + 3, "nested sum placeholder")
})

print("=== Nested Structures Tests Complete ===")

