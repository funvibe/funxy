// Test extension methods

// Define an ADT
type Container<t> = Box t

// Define extension method
fun (b: Container<t>) unbox() -> t {
    match b {
        Box(v) -> v
    }
}

b = Box(42)
print(b.unbox())

// Define extension on primitive
fun (i: Int) double() -> Int {
    i * 2
}

print(10.double())

// Define extension on Record
type alias Point = { x: Int, y: Int }
fun (p: Point) sum() -> Int {
    p.x + p.y
}

pt: Point = { x: 10, y: 20 }
print(pt.sum())

// Test implicit generic resolution (List)
// List is built-in but handled as List a
// Extension on List
fun (l: List<t>) len_plus_one() -> Int {
    len(l) + 1
}

lst = [1, 2, 3]
print(lst.len_plus_one())

// Test extension on Union Type alias
type alias Number = Float | Int

fun (n: Number) add(m) {
    n + m
}

print(1.add(2))
print(1.5.add(2.5))
