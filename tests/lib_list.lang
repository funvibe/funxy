import "lib/list" (*)

// =============================================
// head: List<t> -> t
// =============================================
fun headSemantics(xs: List<t>) -> t {
    match xs {
        [x, ...rest] -> x
        [] -> panic("head: empty list")
    }
}
lst = [1, 2, 3]
a = head(lst)
b = headSemantics(lst)
print(a == b)  // true

// =============================================
// headOr: (List<t>, t) -> t
// =============================================
fun headOrSemantics(xs: List<t>, fallback: t) -> t {
    match xs {
        [x, ...rest] -> x
        [] -> fallback
    }
}
print(headOr([1, 2], 0) == headOrSemantics([1, 2], 0))  // true
print(headOr([], 0) == headOrSemantics([], 0))          // true

// =============================================
// last: List<t> -> t
// =============================================
fun lastSemantics(xs: List<t>) -> t {
    match xs {
        [x] -> x
        [h, ...rest] -> lastSemantics(rest)
        [] -> panic("last: empty list")
    }
}
print(last([1, 2, 3]) == lastSemantics([1, 2, 3]))  // true

// =============================================
// lastOr: (List<t>, t) -> t
// =============================================
fun lastOrSemantics(xs: List<t>, fallback: t) -> t {
    match xs {
        [x] -> x
        [h, ...rest] -> lastOrSemantics(rest, fallback)
        [] -> fallback
    }
}
print(lastOr([1, 2, 3], 0) == lastOrSemantics([1, 2, 3], 0))  // true
print(lastOr([], 0) == lastOrSemantics([], 0))                // true

// =============================================
// nth: (List<t>, Int) -> t
// =============================================
fun nthSemantics(xs: List<t>, n: Int) -> t {
    match (xs, n) {
        ([x, ...rest], 0) -> x
        ([h, ...rest], m) -> nthSemantics(rest, m - 1)
        ([], m) -> panic("nth: index out of bounds")
    }
}
print(nth([10, 20, 30], 0) == nthSemantics([10, 20, 30], 0))  // true
print(nth([10, 20, 30], 2) == nthSemantics([10, 20, 30], 2))  // true

// =============================================
// nthOr: (List<t>, Int, t) -> t
// =============================================
fun nthOrSemantics(xs: List<t>, n: Int, fallback: t) -> t {
    match (xs, n) {
        ([x, ...rest], 0) -> x
        ([h, ...rest], m) -> nthOrSemantics(rest, m - 1, fallback)
        ([], m) -> fallback
    }
}
print(nthOr([10, 20], 5, -1) == nthOrSemantics([10, 20], 5, -1))  // true

// =============================================
// tail: List<t> -> List<t>
// =============================================
fun tailSemantics(xs: List<t>) -> List<t> {
    match xs {
        [h, ...rest] -> rest
        [] -> panic("tail: empty list")
    }
}
print(tail([1, 2, 3]) == tailSemantics([1, 2, 3]))  // true

// =============================================
// init: List<t> -> List<t>
// =============================================
fun initSemantics(xs: List<t>) -> List<t> {
    match xs {
        [x] -> []
        [x, ...rest] -> x :: initSemantics(rest)
        [] -> panic("init: empty list")
    }
}
print(init([1, 2, 3]) == initSemantics([1, 2, 3]))  // true

// =============================================
// take: (List<t>, Int) -> List<t>
// =============================================
fun takeSemantics(xs: List<t>, n: Int) -> List<t> {
    if n <= 0 { [] }
    else {
        match xs {
            [x, ...rest] -> x :: takeSemantics(rest, n - 1)
            [] -> []
        }
    }
}
print(take([1, 2, 3, 4, 5], 3) == takeSemantics([1, 2, 3, 4, 5], 3))  // true

// =============================================
// drop: (List<t>, Int) -> List<t>
// =============================================
fun dropSemantics(xs: List<t>, n: Int) -> List<t> {
    if n <= 0 { xs }
    else {
        match xs {
                [h, ...rest] -> dropSemantics(rest, n - 1)
            [] -> []
        }
    }
}
print(drop([1, 2, 3, 4, 5], 2) == dropSemantics([1, 2, 3, 4, 5], 2))  // true

// =============================================
// isEmpty: List<t> -> Bool
// =============================================
fun isEmptySemantics(xs: List<t>) -> Bool {
    match xs {
        [] -> true
        _ -> false
    }
}
print(isEmpty([]) == isEmptySemantics([]))      // true
print(isEmpty([1]) == isEmptySemantics([1]))    // true

// =============================================
// length: List<t> -> Int
// =============================================
fun lengthSemantics(xs: List<t>) -> Int {
    match xs {
        [] -> 0
        [h, ...rest] -> 1 + lengthSemantics(rest)
    }
}
print(length([1, 2, 3]) == lengthSemantics([1, 2, 3]))  // true

// =============================================
// filter: (List<t>, (t) -> Bool) -> List<t>
// =============================================
fun filterSemantics(xs: List<t>, pred: (t) -> Bool) -> List<t> {
    match xs {
        [] -> []
        [x, ...rest] -> if pred(x) { x :: filterSemantics(rest, pred) } else { filterSemantics(rest, pred) }
    }
}
print(filter(fun(x) -> x > 2, [1, 2, 3, 4]) == filterSemantics([1, 2, 3, 4], fun(x) -> x > 2))  // true

// =============================================
// map: (List<t>, (t) -> u) -> List<u>
// =============================================
fun mapSemantics(xs: List<t>, f: (t) -> u) -> List<u> {
    match xs {
        [] -> []
        [x, ...rest] -> f(x) :: mapSemantics(rest, f)
    }
}
print(map(fun(x) -> x * 2, [1, 2, 3]) == mapSemantics([1, 2, 3], fun(x) -> x * 2))  // true

// =============================================
// contains: (List<t>, t) -> Bool
// =============================================
fun containsSemantics(xs: List<t>, elem: t) -> Bool {
    match xs {
        [] -> false
        [x, ...rest] -> if x == elem { true } else { containsSemantics(rest, elem) }
    }
}
print(contains([1, 2, 3], 2) == containsSemantics([1, 2, 3], 2))  // true
print(contains([1, 2, 3], 5) == containsSemantics([1, 2, 3], 5))  // true

// =============================================
// indexOf: (List<t>, t) -> Option<Int>
// =============================================
fun indexOfSemantics(xs: List<t>, elem: t) -> Option<Int> {
    indexOfHelperS(xs, elem, 0)
}
fun indexOfHelperS(xs: List<t>, elem: t, idx: Int) -> Option<Int> {
    match xs {
        [] -> None
        [x, ...rest] -> if x == elem { Some(idx) } else { indexOfHelperS(rest, elem, idx + 1) }
    }
}
print(indexOf([10, 20, 30], 20) == indexOfSemantics([10, 20, 30], 20))  // true (Some(1))
print(indexOf([10, 20, 30], 99) == indexOfSemantics([10, 20, 30], 99))  // true (None)

// =============================================
// reverse: List<t> -> List<t>
// =============================================
fun reverseSemantics(xs: List<t>) -> List<t> {
    reverseHelperS(xs, [])
}
fun reverseHelperS(xs: List<t>, acc: List<t>) -> List<t> {
    match xs {
        [] -> acc
        [x, ...rest] -> reverseHelperS(rest, x :: acc)
    }
}
print(reverse([1, 2, 3]) == reverseSemantics([1, 2, 3]))  // true

// =============================================
// concat: (List<t>, List<t>) -> List<t>
// =============================================
fun concatSemantics(xs: List<t>, ys: List<t>) -> List<t> {
    xs ++ ys
}
print(concat([1, 2], [3, 4]) == concatSemantics([1, 2], [3, 4]))  // true

// =============================================
// flatten: List<List<t>> -> List<t>
// =============================================
fun flattenSemantics(xss: List<List<t>>) -> List<t> {
    match xss {
        [] -> []
        [xs, ...rest] -> xs ++ flattenSemantics(rest)
    }
}
print(flatten([[1, 2], [3]]) == [1, 2, 3])  // true
print(flatten([[1, 2], [3, 4], [5]]) == flattenSemantics([[1, 2], [3, 4], [5]]))  // true

// =============================================
// unique: List<t> -> List<t>
// =============================================
fun uniqueSemantics(xs: List<t>) -> List<t> {
    uniqueHelperS(xs, [])
}
fun uniqueHelperS(xs: List<t>, seen: List<t>) -> List<t> {
    match xs {
        [] -> []
        [x, ...rest] -> {
            if containsSemantics(seen, x) {
                uniqueHelperS(rest, seen)
            } else {
                x :: uniqueHelperS(rest, x :: seen)
            }
        }
    }
}
print(unique([1, 2, 2, 3, 1]) == uniqueSemantics([1, 2, 2, 3, 1]))  // true

// =============================================
// zip: (List<a>, List<b>) -> List<(a, b)>
// =============================================
fun zipSemantics(xs: List<a>, ys: List<b>) -> List<(a, b)> {
    match (xs, ys) {
        ([x, ...xrest], [y, ...yrest]) -> (x, y) :: zipSemantics(xrest, yrest)
        _ -> []
    }
}
print(zip([1, 2], [3, 4]) == zipSemantics([1, 2], [3, 4]))  // true

// =============================================
// unzip: List<(a, b)> -> (List<a>, List<b>)
// =============================================
fun unzipSemantics(prs: List<(a, b)>) -> (List<a>, List<b>) {
    match prs {
        [] -> ([], [])
        [first, ...rest] -> {
            (fst, snd) = first
            (fsts, snds) = unzipSemantics(rest)
            ([fst, ...fsts], [snd, ...snds])
        }
    }
}
pairs: List<(Int, Int)> = [(1, 3), (2, 4)]
print(unzip(pairs) == ([1, 2], [3, 4]))              // true
print(unzip(pairs) == unzipSemantics(pairs))        // true

// =============================================
// sort: List<t> -> List<t> (requires Order constraint)
// =============================================
fun sortSemantics<t: Order>(xs: List<t>) -> List<t> {
    match xs {
        [] -> []
        [pivot, ...rest] -> {
            less = filterSemantics(rest, fun(x) -> x < pivot)
            greater = filterSemantics(rest, fun(x) -> x >= pivot)
            sortSemantics(less) ++ [pivot] ++ sortSemantics(greater)
        }
    }
}
print(sort([3, 1, 2]) == [1, 2, 3])  // true
print(sort([3, 1, 4, 1, 5, 9, 2, 6]) == sortSemantics([3, 1, 4, 1, 5, 9, 2, 6]))  // true

// =============================================
// sortBy: (List<t>, (t,t)->Int) -> List<t>
// =============================================
words = ["banana", "apple", "kiwi"]
cmp = fun(a, b) -> length(a) - length(b)
print(sortBy(words, cmp) == ["kiwi", "apple", "banana"])  // true

// =============================================
// foldl: (List<t>, u, (u, t) -> u) -> u
// =============================================
fun foldlSemantics(xs: List<t>, init: u, f: (u, t) -> u) -> u {
    match xs {
        [] -> init
            [x, ...rest] -> foldlSemantics(rest, f(init, x), f)
    }
}
print(foldl((+), 0, [1, 2, 3, 4]) == foldlSemantics([1, 2, 3, 4], 0, (+)))  // true (10)
print(foldl(fun(acc, x) -> acc - x, 0, [1, 2, 3]) == -6)  // true: ((0-1)-2)-3 = -6

// =============================================
// foldr: (List<t>, u, (t, u) -> u) -> u
// =============================================
fun foldrSemantics(xs: List<t>, init: u, f: (t, u) -> u) -> u {
    match xs {
        [] -> init
        [x, ...rest] -> f(x, foldrSemantics(rest, init, f))
    }
}
print(foldr((+), 0, [1, 2, 3, 4]) == foldrSemantics([1, 2, 3, 4], 0, (+)))  // true (10)
print(foldr(fun(x, acc) -> x - acc, 0, [1, 2, 3]) == 2)  // true: 1-(2-(3-0)) = 2

// =============================================
// find: (List<t>, (t) -> Bool) -> Option<t>
// =============================================
fun findSemantics(xs: List<t>, pred: (t) -> Bool) -> Option<t> {
    match xs {
        [] -> None
        [x, ...rest] -> if pred(x) { Some(x) } else { findSemantics(rest, pred) }
    }
}
print(find(fun(x) -> x > 2, [1, 2, 3, 4]) == Some(3))  // true
print(find(fun(x) -> x > 10, [1, 2, 3]) == None)       // true
print(find(fun(x) -> x > 2, [1, 2, 3, 4]) == findSemantics([1, 2, 3, 4], fun(x) -> x > 2))  // true

// =============================================
// findIndex: (List<t>, (t) -> Bool) -> Option<Int>
// =============================================
print(findIndex(fun(x) -> x > 2, [1, 2, 3, 4]) == Some(2))  // true (index of 3)
print(findIndex(fun(x) -> x > 10, [1, 2, 3]) == None)       // true

// =============================================
// any: (List<t>, (t) -> Bool) -> Bool
// =============================================
fun anySemantics(xs: List<t>, pred: (t) -> Bool) -> Bool {
    match xs {
        [] -> false
        [x, ...rest] -> if pred(x) { true } else { anySemantics(rest, pred) }
    }
}
print(any(fun(x) -> x > 2, [1, 2, 3]) == true)   // true
print(any(fun(x) -> x > 10, [1, 2, 3]) == false) // true
print(any(fun(x) -> x > 2, [1, 2, 3]) == anySemantics([1, 2, 3], fun(x) -> x > 2))  // true

// =============================================
// all: (List<t>, (t) -> Bool) -> Bool
// =============================================
fun allSemantics(xs: List<t>, pred: (t) -> Bool) -> Bool {
    match xs {
        [] -> true
        [x, ...rest] -> if pred(x) { allSemantics(rest, pred) } else { false }
    }
}
print(all(fun(x) -> x > 0, [1, 2, 3]) == true)   // true
print(all(fun(x) -> x > 2, [1, 2, 3]) == false)  // true
print(all(fun(x) -> x > 0, [1, 2, 3]) == allSemantics([1, 2, 3], fun(x) -> x > 0))  // true

// =============================================
// takeWhile: (List<t>, (t) -> Bool) -> List<t>
// =============================================
fun takeWhileSemantics(xs: List<t>, pred: (t) -> Bool) -> List<t> {
    match xs {
        [] -> []
        [x, ...rest] -> if pred(x) { x :: takeWhileSemantics(rest, pred) } else { [] }
    }
}
print(takeWhile(fun(x) -> x < 4, [1, 2, 3, 4, 5]) == [1, 2, 3])  // true
print(takeWhile(fun(x) -> x > 10, [1, 2, 3]) == [])             // true
print(takeWhile(fun(x) -> x < 3, [1, 2, 3, 4]) == takeWhileSemantics([1, 2, 3, 4], fun(x) -> x < 3))  // true

// =============================================
// dropWhile: (List<t>, (t) -> Bool) -> List<t>
// =============================================
fun dropWhileSemantics(xs: List<t>, pred: (t) -> Bool) -> List<t> {
    match xs {
        [] -> []
        [x, ...rest] -> if pred(x) { dropWhileSemantics(rest, pred) } else { xs }
    }
}
print(dropWhile(fun(x) -> x < 4, [1, 2, 3, 4, 5]) == [4, 5])  // true
print(dropWhile(fun(x) -> x > 10, [1, 2, 3]) == [1, 2, 3])    // true
print(dropWhile(fun(x) -> x < 3, [1, 2, 3, 4]) == dropWhileSemantics([1, 2, 3, 4], fun(x) -> x < 3))  // true

// =============================================
// partition: (List<t>, (t) -> Bool) -> (List<t>, List<t>)
// =============================================
fun partitionSemantics(xs: List<t>, pred: (t) -> Bool) -> (List<t>, List<t>) {
    match xs {
        [] -> ([], [])
        [x, ...rest] -> {
            (yes, no) = partitionSemantics(rest, pred)
            if pred(x) { (x :: yes, no) } else { (yes, x :: no) }
        }
    }
}
print(partition(fun(x) -> x % 2 == 0, [1, 2, 3, 4, 5]) == ([2, 4], [1, 3, 5]))  // true
print(partition(fun(x) -> x % 2 == 0, [1, 2, 3, 4, 5]) == partitionSemantics([1, 2, 3, 4, 5], fun(x) -> x % 2 == 0))  // true

// =============================================
// forEach: ((t) -> Nil, List<t>) -> Nil
// =============================================

// forEach executes a function for each element (side effects only)
// It always returns Nil

// Test 1: forEach returns Nil
result = forEach(fun(x) -> { Nil }, [1, 2, 3])
print(result == Nil)  // true

// Test 2: forEach executes for all elements (using mutable accumulator pattern)
// Wrap in function to allow closure mutation
fun testForEachCount() {
    count = 0
    forEach(fun(x) -> { count = count + 1, Nil }, [1, 2, 3, 4, 5])
    print(count == 5)  // true
}
testForEachCount()

// Test 3: forEach with empty list
fun testForEachEmpty() {
    count2 = 0
    forEach(fun(x) -> { count2 = count2 + 1, Nil }, [])
    print(count2 == 0)  // true
}
testForEachEmpty()

// Test 4: forEach in pipe
fun testForEachPipe() {
    sum = 0
    [10, 20, 30] |> forEach(fun(x) -> { sum = sum + x, Nil })
    print(sum == 60)  // true
}
testForEachPipe()

// =============================================
// range: (Int, Int) -> List<Int>
// =============================================
fun rangeSemantics(start: Int, end: Int) -> List<Int> {
    if start >= end { [] } else { start :: rangeSemantics(start + 1, end) }
}
print(range(1, 5) == [1, 2, 3, 4])  // true
print(range(0, 3) == [0, 1, 2])     // true
print(range(5, 5) == [])            // true (empty when start >= end)
print(range(10, 5) == [])           // true (empty when start > end)
print(range(1, 5) == rangeSemantics(1, 5))  // true

// =============================================
// append: (List<t>, t) -> List<t>
// =============================================
fun appendSemantics(xs: List<t>, elem: t) -> List<t> {
    xs ++ [elem]
}
print(append([1, 2], 3) == [1, 2, 3])  // true
print(append([], 1) == [1])            // true
print(append([1], 2) == appendSemantics([1], 2))  // true

// =============================================
// insert: (List<t>, Int, t) -> List<t>
// =============================================
fun insertSemantics(xs: List<t>, idx: Int, val: t) -> List<t> {
    take(xs, idx) ++ [val] ++ drop(xs, idx)
}
print(insert([1, 3], 1, 2) == [1, 2, 3])  // true
print(insert([], 0, 1) == [1])            // true
print(insert([1, 2], 2, 3) == [1, 2, 3])  // true (append via insert)
print(insert([1, 3], 1, 2) == insertSemantics([1, 3], 1, 2))  // true

// =============================================
// update: (List<t>, Int, t) -> List<t>
// =============================================
fun updateSemantics(xs: List<t>, idx: Int, val: t) -> List<t> {
    take(xs, idx) ++ [val] ++ drop(xs, idx + 1)
}
print(update([1, 2, 3], 1, 99) == [1, 99, 3])  // true
print(update([1], 0, 99) == [99])              // true
print(update([1, 2, 3], 1, 99) == updateSemantics([1, 2, 3], 1, 99))  // true

print("All lib/list tests passed!")
