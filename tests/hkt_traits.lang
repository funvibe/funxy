// Tests for automatic HKT detection via IsHKTTrait
// Testing different kinds: * -> *, * -> * -> *, and non-HKT traits

// ===========================================================================
// Test 1: Non-HKT trait (T used directly, kind *)
// ===========================================================================

trait Printable<t> {
    fun display(x: t) -> String
}

// Should work with concrete type - no kind restriction
instance Printable<Int> {
    fun display(x: Int) -> String { "int" }
}

instance Printable<String> {
    fun display(x: String) -> String { "string" }
}

print(display(42))       // int
print(display("hello"))  // string

// ===========================================================================
// Test 2: HKT trait with * -> * (one type param like Functor)
// ===========================================================================

// Note: Functor is now built-in, so we test with a custom HKT trait
trait Container<c> {
    fun contents(con: c<a>) -> a
}

// Should work with Option (kind * -> *)
instance Container<Option> {
    fun contents(con: Option<a>) -> a {
        match con { Some(x) -> x; Zero -> panic("empty") }
    }
}

// Should work with List (kind * -> *)
instance Container<List> {
    fun contents(con: List<a>) -> a {
        match con { [x, ..._] -> x; [] -> panic("empty") }
    }
}

print(contents(Some(42)))  // 42
print(contents([10, 20]))  // 10

// ===========================================================================
// Test 3: HKT trait with * -> * -> * (two type params like Bifunctor)
// ===========================================================================

trait Bifunctor<b> {
    fun bimap(f: (a) -> c, g: (d) -> e, x: b<a, d>) -> b<c, e>
}

// Result has kind * -> * -> * with Result<E, A> (error first, success last)
instance Bifunctor<Result> {
    // B<A, D> = Result<A, D> where A is first param (error), D is second param (success)
    // f: (A) -> C maps error, g: (D) -> E maps success
    fun bimap(f: (a) -> c, g: (d) -> e, x: Result<a, d>) -> Result<c, e> {
        match x {
            Ok(d) -> Ok(g(d))      // success (D) transformed by g
            Fail(a) -> Fail(f(a))  // error (A) transformed by f
        }
    }
}

// bimap(errorFn, successFn, value)
res1 = bimap(fun(e) -> e ++ "!", fun(x) -> x * 2, Ok(21))
print(res1)  // Ok(42)

res2 = bimap(fun(e) -> e ++ "!", fun(x) -> x * 2, Fail("err"))
print(res2)  // Fail("err!")

// ===========================================================================
// Test 4: Functor (built-in trait, instances already registered)
// ===========================================================================

// Functor instances for Option, List, Result are now built-in
print(fmap(fun(x) -> x * 2, Some(21)))     // Some(42)
print(fmap(fun(x) -> x * 2, [1, 2, 3]))    // [2, 4, 6]
print(fmap(fun(x) -> x * 2, Ok(50)))       // Ok(100)
print(fmap(fun(x) -> x * 2, Fail("err")))  // Fail("err")

print("HKT traits test passed!")

