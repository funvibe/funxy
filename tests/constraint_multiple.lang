// Test: Multiple constraints on same type variable
// New syntax: t: Trait1, Trait2, Trait3

trait Printable<t> {
    fun pretty(val: t) -> String
}

trait Cmp<t> {
    fun cmp(a: t, b: t) -> Bool
}

instance Printable Int {
    fun pretty(val: Int) -> String { "int" }
}

instance Cmp Int {
    fun cmp(a: Int, b: Int) -> Bool { a == b }
}

// Function with multiple constraints - t must implement BOTH Printable AND Cmp
fun process<t: Printable, Cmp>(x: t, y: t) -> String {
    if cmp(x, y) {
        pretty(x)
    } else {
        "different"
    }
}

print(process(5, 5))    // int (same)
print(process(1, 2))    // different
