// =============================================================================
// HKT Step 1: F<A> in function signatures
// =============================================================================
// Goal: Allow type variables to be applied to other type variables
// Example: F<A> where F is a type constructor variable

// -----------------------------------------------------------------------------
// Test 1.1: Simple identity for container (1 type arg)
// -----------------------------------------------------------------------------

// F is a type constructor (like Option, List), A is element type
fun hktId<f, a>(fa: f<a>) -> f<a> {
    fa
}

// Should work with Option
opt1 = hktId(Some(42))
print(opt1)  // Some(42)

// Should work with List
list1 = hktId([1, 2, 3])
print(list1)  // [1, 2, 3]

// -----------------------------------------------------------------------------
// Test 1.2: Identity for two-arg type constructors (like Result)
// -----------------------------------------------------------------------------

fun hktId2<f, a, b>(fab: f<a, b>) -> f<a, b> {
    fab
}

// Should work with Result
res1 = hktId2(Ok("hello"))
print(res1)  // Ok("hello")

res2 = hktId2(Fail(404))
print(res2)  // Fail(404)

// -----------------------------------------------------------------------------
// Test 1.3: Function that transforms inside container
// -----------------------------------------------------------------------------

fun wrap<f, a>(x: a, wrapper: (a) -> f<a>) -> f<a> {
    wrapper(x)
}

opt2 = wrap(10, Some)
print(opt2)  // Some(10)

// -----------------------------------------------------------------------------
// Test 1.4: Two container types in one function
// -----------------------------------------------------------------------------

fun convert<f, g, a>(fa: f<a>, converter: (f<a>) -> g<a>) -> g<a> {
    converter(fa)
}

// Convert Option to List
optToList = fun(opt: Option<Int>) -> List<Int> {
    match opt {
        Some(x) -> [x]
        None -> []
    }
}

list2 = convert(Some(5), optToList)
print(list2)  // [5]

list3 = convert(None, optToList)
print(list3)  // []

// -----------------------------------------------------------------------------
// Test 1.5: Nested type application F<G<A>>
// -----------------------------------------------------------------------------

fun nested<f, g, a>(fga: f<g<a>>) -> f<g<a>> {
    fga
}

// List of Options
listOpts = nested([Some(1), Some(2), None])
print(listOpts)  // [Some(1), Some(2), None]

// Option of List
optList = nested(Some([1, 2, 3]))
print(optList)  // Some([1, 2, 3])

print("Step 1 passed!")
