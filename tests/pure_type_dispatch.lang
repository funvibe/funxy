// Test pure/mempty dispatch based on expected return type from TypeMap

// Define Applicative trait with pure
trait MyApplicative<f> {
    fun myPure(x: a) -> f<a>
}

// Instance for Option
instance MyApplicative<Option> {
    fun myPure(x: a) -> Option<a> {
        Some(x)
    }
}

// Instance for List
instance MyApplicative<List> {
    fun myPure(x: a) -> List<a> {
        [x]
    }
}

// Test with explicit type annotation - analyzer knows the expected type!
opt: Option<Int> = myPure(42)
print(opt)  // Should print Some(42)

kOpt: Option<Int> :- myPure(7)
print(kOpt)  // Should print Some(7)

lst: List<Int> = myPure(100)
print(lst)  // Should print [100]

// Test with String
optStr: Option<String> = myPure("hello")
print(optStr)

lstStr: List<String> = myPure("world")
print(lstStr)

print("pure type dispatch test passed!")

